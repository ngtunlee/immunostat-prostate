---
title: "Antigen Specificity of TCR Sequences"
author: "Tun Lee Ng"
date: "`r format(Sys.time(), '%B %d, %Y')`"
header-includes:
    - \usepackage{amsmath}
output: 
  html_document:
    number_sections: true
---

<style type="text/css">

h1.title {
  text-align: center;
}
h4.author {
  text-align: center;
}
h4.date {
  text-align: center;
}
body {
  font-size: 12pt;
  text-align: justify;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
```

```{r}
library(kableExtra) # tables
library(tidyverse)
library(janitor) # tabyl
library(ggplot2)
```

# Introduction

Prostate cancer immunotherapy involves vaccination with protein fragments that are present on prostate cancer cells in order to elicit production of antigen-specific CD8+ T-cells to (hopefully) seek out and kill prostate cancer cells. Specifically, the T-cell receptors (TCRs) are the unique regions of T-cells responsible for specific antigen recognition. When any one of these T-cells encounters an antigen that binds to its unique TCR, the T-cell replicates and these clones would proceed to kill tumor cells in the body. However, recent clinical trials revealed that production of T-cells does increase with vaccination but tumor-killing has been underwhelming, due to specific immunosuppressive effects within tumor microenvironment. Further investigation on T-cells (more specifically, their TCR sequences), especially those from within a tumor, could help to improve our overall understanding about cancer immunotherapy.  

Currently, we know that the TCRs could recognize 7 sequences (ie. MHC-I restricted epitopes) corresponding to 3 different proteins found on prostate cancer cells. These proteins are our target antigens for which we have designed and are testing DNA vaccines:  

* Prostatic acid phosphatase (PAP) has 3 MHC-I restricted epitopes, PAP-p11, PAP-p15 and PAP-p19  
* Androgen receptor (AR) has 2 MHC-I restricted epitopes, AR-p805 and AR-p811  
* Synovial sarcoma, X breakpoint 2 (SSX2) also has 2 MHC-I restricted epitopes, SSX2-p41 and SSX2-p103.  

The objectives of this study are:  

1. to determine if we can identify TCR sequences that are unique to specific antigen -- it is possible that there are no antigen-specific TCR sequences and that every T-cell that recognizes a certain antigen is unique.  
2. to compare the TCR sequences of mice immunized with one particular antigen against those of mice immunized with the whole DNA vaccine -- without purifying antigen-specific T-cells, could we still find the same set of TCR sequences as we would in those antigen-specific settings?  
3. to compare the TCR sequences between healthy subjects and tumor-bearing subjects.  
4. (if all 1 - 3 work) Use the TCR sequences in conjunction with scRNA to assess gene expression profiles of tumor-infiltrating T-cells in order to determine what agents will work to enhance the anti-tumor responses to the vaccines.   

Here is the experimental design:

```{r}
data.frame(
  Vaccine = c("PAP11", "PAP15", "PAP19", "AR805", "AR811", "SSX241", "SSX2103", "whole DNA"),
  Healthy_mice = rep("spleen only", 8),
  Tumor_bearing_mice = rep("spleen and tumor", 8)
) %>% knitr::kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, font_size = 12)
```

Each treatment group has 10 mice. Mice of the same treatment group are immunized with peptides that encode the specific MHC-I restricted epitopes listed above. Mice's spleens are then harvested and their T-cells are collected via FACS (for tunor-bearing mice, T-cells are collected from both spleen and tumor). Their RNAs that code for the TCR variable regions are captured with the [Takara kit](https://www.takarabio.com/products/next-generation-sequencing/immune-profiling/human-repertoire/human-tcr-profiling-kit-for-illumina-sequencing) and sequenced with NGS.     

# Data

First, we try to achieve Objective I. Unfortunately, due to the on-going pandemic since circa March 2020, we only have 15 samples thus far (11 healthy mice, 2 positive controls and 2 negative controls -- more description about these controls later). The fastq files are stored in K-Drive. [FastQC report](https://github.com/wiscstatman/immunostat/blob/master/TCRseq/_multiqc_report.html) indicates that quality for most of the samples are reasonable, except for *AR811_S5* and *PAP19_S5* which have total sequences (less than 1E5) and mean quality scores lower than the other samples -- should/could we re-sequence these samples? Mean quality scores for all samples deteriorate gradually after 100bp. For this preliminary analysis, we retain all base pairs but moving forward, should we also consider trimming the latter base pairs before proceeding to subsequent/downstream analysis?  

These fastq files are fed into [MiXCR](https://mixcr.readthedocs.io/en/master/index.html) software -- "a universal framework that processes big immunome data from raw sequences to quantitated clonotypes". In particular, we rely on its built-in pipeline [*analyze amplicon*](https://mixcr.readthedocs.io/en/master/analyze.html) to align the raw reads, assemble the clonotypes and export human-readable reports and clonotype .txt spreadsheets. Currently, we use all the default parameters in the software but moving forward, we might want to investigate more on the default parameters in the [clonotype assembly step](https://mixcr.readthedocs.io/en/master/assemble.html). The reports and clonotype files are store in [Box](https://uwmadison.app.box.com/folder/111540216221).  

In addition, we might want to consider other processing step after/in-conjunction-with MiXCR as suggested in this [paper](https://www.nature.com/articles/s41598-017-11310-0), in which the authors claimed that "MiXCR erroneously extracted many non-TCR reads. For example, somatically mutated immunoglobulin CDR3 regions may resemble those of TCR. Therefore, they performed additional filtering steps to exclude sequences transcribed from non-TCR loci".   

We want to take a closer look at these clonotype files to explore clonality/diversity of TCR sequences for specific antigens. First, append these .txt spreadsheets into a single data frame for easier data wrangling. Here is a snippet of the combined data frame:   

```{r}
clonotype_path = "C:/Users/apoca/Documents/TCRseq/MiXCR_Results/txt_files"

# get filenames of all clonotype txt file
clonotype_files = dir(path = clonotype_path, pattern = "*.clonotypes.ALL.txt")

# get all tables into 1 nice table
dat <- clonotype_files %>%
  map( function(x){ # return a list of tables
    read_delim( file.path(clonotype_path, x), delim = "\t" ) %>%
      select( cloneCount, cloneFraction, targetSequences, targetQualities, minQualCDR3, aaSeqCDR3 ) %>% # keep specific columns
      mutate(
        antigen = strsplit(x, "-", fixed = T)[[1]][1],
        sample = paste0( "S-", strsplit(strsplit(x, "_", fixed = T)[[1]][1], "-", fixed = T)[[1]][2] ),
        # rev_cumsum = rev( cumsum( rev(cloneFraction) ) ), # cumulative clone fraction from bottom row to top row
        cumsum_cloneFrac = cumsum( cloneFraction ) # cumulative clone fraction from top row to bottom row
      ) %>%
      select(antigen, sample, cloneCount, cloneFraction, cumsum_cloneFrac, aaSeqCDR3, everything()) # rearrange columns
  } ) %>% 
  reduce(rbind) # reduce(append) lists of tables into a table 

dat[1:10,] %>% knitr::kable() %>%
  kable_styling(bootstrap_options = "striped", font_size = 10) %>%
  scroll_box(width = "100%", height = "300px")
```
  
Here are some basic summaries, grouped by antigens and samples:

```{r}
basic_summary_df <- dat %>%
  group_by(antigen, sample) %>%
  summarize(
    sum_cloneCounts = sum(cloneCount), 
    unique_targetSeq_counts = length(unique(targetSequences)), # equal to nrows=n()
    unique_aaSeqCDR3_counts = length(unique(aaSeqCDR3))
  ) 

basic_summary_df %>% knitr::kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = F, font_size = 12)
```
  
For example, MiXCR identifies `r basic_summary_df[1,'unique_targetSeq_counts']` ``targetSequences`` for `r paste0(basic_summary_df[1, 'antigen'],"_",basic_summary_df[1, 'sample'])` (where almost all of them are associated with unique ``aaSeqCDR3``) and their associated clone counts, which sum up to `r basic_summary_df[1,'sum_cloneCounts']`. Note that counts of unique ``aaSeqCDR3`` are slightly smaller than the counts of unique ``targetSequences`` -- this is not surprising since different triplicates in a reading frame would be translated to the same amino acid?  

``PosCont`` refers to positive controls which are run with control RNA that came with the Takara sequencing kit, whereas ``NegCont`` refers to negative controls which are run with NO RNA. Thus, these are technical (NOT biological) controls. We do not have negative or positive biological controls as there are no consistent TCR sequences. If we were to run TCR sequencing on non-immunized mice, we would just get a random sample of that particular mouse's TCR sequences. Each mouse will naturally have its own clones but they will not be the same across mice, even though they are genetically identical due to the rearrangements that occur at the RNA level, not the DNA - i.e. All these mice have the same DNA but completely random TCRs, because once the DNA is converted to RNA, it gets scrambled up randomly before being converted to the protein that makes up the receptor.  

# Exploratory Analysis

## Positive Controls

First, take a peek at the snippet of the two samples of positive controls ``PosCont``.

```{r}
head(dat %>% filter(antigen == "PosCont", sample == "S-1")) %>%
  knitr::kable() %>%
  kable_styling(bootstrap_options = "striped", font_size = 10) %>%
  scroll_box(width = "100%", height = "200px")
```

```{r}
head(dat %>% filter(antigen == "PosCont", sample == "S-2")) %>%
  knitr::kable() %>%
  kable_styling(bootstrap_options = "striped", font_size = 10) %>%
  scroll_box(width = "100%", height = "200px")
```

Looks like the positive controls are working -- maybe check these numbers with Takara handbook/manual? We proceed to exclude positive controls from our subsequent analysis. 

## Overall Clonal Distribution

```{r, echo = T}
# remove positive controls?
dat <- dat %>% filter(antigen != "PosCont")

# filter non-NegCont samples
dat_ex_NegCont <- dat %>% filter(antigen != "NegCont")

# filter NegCont only
NegCont <- dat %>% filter(antigen == "NegCont")
```

Among the non-negative-control samples, most of the ``targetSequences`` are associated with very small clone fractions. 

```{r}
prcntile <- c(.95, .97, .98, .99, .995)
round(quantile(dat_ex_NegCont$cloneFraction, probs = prcntile),4)
```

For example, 98.66\% of "target sequences" for all non-negative-control samples have clone fractions lower than 1\%. The top 10 ``targetSequences`` (ranked by largest clone fraction) usually account for most of the clone fractions for a particular sample, as evident from the following bar chart:

```{r, fig.height= 6, fig.width = 10, fig.align="center"}
cumcloneFrac_topSeq_df <- dat_ex_NegCont %>%
  group_by(antigen, sample) %>%
  top_n(10, cloneFraction) %>%
  top_n(1, cumsum_cloneFrac) %>%
  mutate( cumsum_cloneFrac = round(cumsum_cloneFrac,4) ) %>%
  unite(antigen_sample, antigen, sample, sep = "_", remove = T) %>%
  select(antigen_sample, cumsum_cloneFrac) 

ggplot(data = cumcloneFrac_topSeq_df, aes(x = reorder(antigen_sample, -cumsum_cloneFrac), y = cumsum_cloneFrac)) +
  geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
  coord_cartesian(ylim=c(0, 1.1)) +
  geom_text( aes(label = paste0(cumsum_cloneFrac*100,"%","\n(n=",
                                dat_ex_NegCont %>% group_by(antigen, sample) %>% summarize(n = sum(cloneCount)) %>% pull(n),")")), 
            vjust=-0.3, size=3 ) +
  labs(x = "antigen_sample", y = "cumulative clone fraction",
       title = "Cumulative clone fraction for top 10 sequences of each sample
       (n = total number of clones for each sample)") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x=element_text(angle=45, hjust=1),
        legend.position = "bottom")
```

In addition, the top 3 ``targetSequences`` for each sample dominate the other ``targetSequences`` in terms of associated clone fractions.

```{r, fig.height= 7, fig.width = 11, fig.align="center"}
cloneFrac_topSeq_df2 <- dat_ex_NegCont %>%
  group_by(antigen, sample) %>%
  top_n(3, cloneFraction) %>%
  mutate( sequence = paste0("seq_",row_number()),
          sequence = factor(sequence, levels = paste0("seq_",1:10))) %>% 
  unite(antigen_sample, antigen, sample, sep = "_", remove = T) %>%
  select(antigen_sample, sequence, cloneFraction) %>%
  group_by(antigen_sample) %>% 
  mutate(mx = max(cloneFraction)) %>% 
  arrange(desc(mx), desc(cloneFraction)) 

ggplot(cloneFrac_topSeq_df2, aes(x=reorder(antigen_sample, -mx), y=cloneFraction, fill=sequence)) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_text( aes(label = paste0(round(cloneFraction*100,1),"%")), position = position_dodge(0.9), vjust=-0.3, size=2.5 ) +
  labs(x = "antigen_sample", title = "Clone fraction for top 3 sequences of each sample") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x=element_text(angle=45, hjust=1),
        legend.position = "bottom")
```

## Negative Controls

Meanwhile, snippets for negative controls are as follows: 

```{r}
head(dat %>% filter(antigen == "NegCont", sample == "S-1")) %>%
  knitr::kable() %>%
  kable_styling(bootstrap_options = "striped", font_size = 10) %>%
  scroll_box(width = "100%", height = "200px")
```

```{r}
head(dat %>% filter(antigen == "NegCont", sample == "S-2")) %>%
  knitr::kable() %>%
  kable_styling(bootstrap_options = "striped", font_size = 10) %>%
  scroll_box(width = "100%", height = "200px")
```

Since ``NegCont_S-2`` have very few sequence reads, clone counts of 45 and 20 give rather high clone fractions. For ``NegCont_S-1``, it appears that there is only one ``targetSequence`` with clone fraction slightly higher than 1\%, whereas all other ``targetSequences`` have clone fractions lower than 1\%. We tabulate  ``NegCont_S-1``'s counts of ``targetSequences`` above different clone fraction thresholds.

```{r}
cbind(c("cloneFraction_thresholds", "targetSequence_counts"), rbind(
  paste0(c(.01, .007, .006, .005, .001, .0001)*100,"%"),
  unlist( map(c(.01, .007, .006, .005, .001, .0001), ~ nrow(filter(NegCont, sample == "S-1", cloneFraction > .))) )
)) %>% knitr::kable(format = "html", row.names= NA, col.names = NA, booktabs = T)  %>%
  kable_styling(bootstrap_options = "striped", full_width = T)
```

Only 41 targetSequences of ``NegCont_S-1`` have cloneFraction more than 0.01\%. Recall that negative controls are run without RNA, so naturally we would expect that all ``targetSequences`` for negative controls to have low clone fractions.  

For the purpose of checking these negative controls, we also verify that about half (`r paste0(round(length( which( dat_ex_NegCont$targetSequences %in% NegCont$targetSequences ) )/ nrow(dat_ex_NegCont)*100,2),"%")`) of non-negative-control samples' ``targetSequences`` also appear among those of negative controls (note: these are not based on counts of distinct/unique ``targetSequences``):  

```{r, echo = T}
round(length( which( dat_ex_NegCont$targetSequences %in% NegCont$targetSequences ) )/ nrow(dat_ex_NegCont),4)
```

However, most (`r paste0(round(length( which( !(NegCont$targetSequences %in%  dat_ex_NegCont$targetSequences) ) )/ nrow(NegCont),4) *100, "%") `) of the ``targetSequences`` of negative controls do NOT appear among non-negative-control samples.

```{r}
round(length( which( !(NegCont$targetSequences %in%  dat_ex_NegCont$targetSequences) ) )/ nrow(NegCont),4)
```

Again, these are not based on counts of distinct/unique ``targetSequences``. Next, we verify that among these non-negative-control samples whose ``targetSequences`` also appear in those of negative controls, many of them have high clone counts (and high clone fractions) as tabulated below:

```{r}
# check clone fraction distribution among those non-negative samples with targetSequences that also appear in negative controls
check_clonefrac <- dat_ex_NegCont %>%
  filter(targetSequences %in% NegCont$targetSequences) %>%
  group_by(antigen, sample) %>%
  summarize(
    targetSeq_counts = n(),
    maximum_cloneFrac = round(max(cloneFraction),4),
    maximum_cloneCount = max(cloneCount)
  ) %>% ungroup() %>% mutate(
    targetSeq_percent = targetSeq_counts / (dat_ex_NegCont %>% group_by(antigen, sample) %>% tally() %>% pull(n))
  ) %>% select(-targetSeq_counts) %>% 
  arrange(desc(maximum_cloneFrac)) 

check_clonefrac  %>% knitr::kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = F, font_size = 12)
```

For example, `r paste0(check_clonefrac[1, 'antigen'],"_",check_clonefrac[1, 'sample'])` has `r paste0(round(check_clonefrac[1, 'targetSeq_percent']*100,2),"%")` of its ``targetSequences`` appearing among negative controls, and among these particular ``targetSequences``, the largest clone has a clone fraction of `r paste0(round(check_clonefrac[1, 'maximum_cloneFrac']*100,2),"%") `. On the other hand, among these non-negative-control samples whose ``targetSequences`` do NOT appear in those of negative controls, many of them actually have low clone fractions as tabulated below:

```{r}
# check clone fraction distribution among those non-negative samples with targetSequences that do NOT appear in negative controls
check_clonefrac2 <- dat_ex_NegCont %>%
  filter(!(targetSequences %in% NegCont$targetSequences)) %>%
  group_by(antigen, sample) %>%
  summarize(
    targetSeq_counts = n(),
    maximum_cloneFrac = round(max(cloneFraction),4),
    maximum_cloneCount = max(cloneCount)
  ) %>% ungroup() %>% mutate(
    targetSeq_percent = targetSeq_counts / (dat_ex_NegCont %>% group_by(antigen, sample) %>% tally() %>% pull(n))
  ) %>% select(-targetSeq_counts) %>% 
  arrange(desc(maximum_cloneFrac)) 

check_clonefrac2  %>% knitr::kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = F, font_size = 12)
```

Need to find out more on what exactly these negative controls are -- and could the clone fractions of negative control samples give us some idea about possible "background noise" of other samples?

## Quality Score

Another metric we would like to check is the ``minQualCDR3`` computed by ``MiXCR`` -- is it the minimum sequence quality score among the clones for the particular ``targetSequence``? Most of the ``targetSequences`` among the non-negative-control samples have maximum ``minQualCDR3`` of 38.

```{r, fig.height= 5, fig.width = 8, fig.align="center"}
minQual_df <- dat_ex_NegCont %>% 
  tabyl(minQualCDR3) %>% 
  map_df(rev) %>%
  mutate(percent = ifelse(minQualCDR3 <= 33, sum(percent[minQualCDR3 <= 33]), percent)) %>%
  select(minQualCDR3, percent) %>%
  filter(minQualCDR3 >= 33) %>%
  mutate(minQualCDR3 = as.character(minQualCDR3),
         minQualCDR3 = ifelse(minQualCDR3 == 33, "33 and below", minQualCDR3),
         minQualCDR3 = factor(minQualCDR3, levels = c(38:34,"33 and below")))

ggplot(data=minQual_df, aes(x=minQualCDR3, y=percent)) +
  geom_bar(stat="identity", fill="steelblue")+
  geom_text(aes(label=paste0(round(percent,4)*100, "%")), vjust=-.3, size=3.5)+
  labs(title = "Percentage of targetSequences among non-negative-control samples with their quality scores") +
  theme(plot.title = element_text(hjust = 0.5))
```

We may be able to further improve this if we are able to trim away the latter base pairs before feeding the fastq files to MiXCR? Nonetheless, only ``targetSequences`` with very low clone fractions and/or clone counts have subpar ``minQualCDR3`` less than 38. We extract the "subpar" ``targetSequence`` with largest clone fraction for each sample.

```{r}
dat_ex_NegCont %>% 
  filter(minQualCDR3 < 38) %>% # extract rows with minQualCDR3 < 38
  group_by(antigen, sample) %>%
  top_n(-1, cumsum_cloneFrac) %>% # keep row with smallest cumulative cloneFraction among those with minQualCDR3 < 38 for each sample
  unite(antigen_sample, antigen, sample, sep = "_", remove = T) %>%
  select(antigen_sample, cloneFraction, cloneCount, minQualCDR3) %>%
  arrange(desc(cloneFraction)) %>%
  knitr::kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = F, font_size = 12)
```

## Any antigen-specific sequences?

SO, back to our Objective I: can we identify any antigen-specific sequence? For example, the particular ``targetSequence`` or ``aaSeqCDR3`` only appears in AR805 and not in other antigen?  

For first attempt, let's not filter away any sequence, regardless whether they have very small clone fractions or they have subpar quality score ``minQualCDR3``. 

```{r, echo = T}
cloneFrac_cutoff <- 0 # no cutoff
cloneCount_cutoff <- 0 # no cutoff
```

```{r}
dat_cutoff <- dat_ex_NegCont %>% 
  filter(cloneFraction > cloneFrac_cutoff, cloneCount > cloneCount_cutoff) %>% 
  select(-targetQualities)  %>%
  unite(antigen_sample, antigen, sample, sep = "_", remove = F)

targetSeq_summary <- dat_cutoff %>%
  tabyl(targetSequences, antigen_sample) %>%
  adorn_totals("col") %>%
  arrange(desc(Total)) %>%
  filter(Total >= 2)

# we want to know cloneFraction in summary too

nonzero_index <- which( subset(targetSeq_summary, select = -Total) == 1, arr.ind = T )
summary_cloneFrac <- targetSeq_summary

# Now, replace the ones with their cloneFrac
# maybe a more efficient coding than this?

for (i in 1: nrow(nonzero_index)){
  ant_samp <- colnames(targetSeq_summary)[ nonzero_index[i,]['col'] ]
  targ_seq <- targetSeq_summary$targetSequences[ nonzero_index[i,]['row'] ]
  summary_cloneFrac[ nonzero_index[i,]['row'] , nonzero_index[i,]['col'] ] <- 
    dat_cutoff$cloneFraction[ dat_cutoff$antigen_sample == ant_samp & dat_cutoff$targetSequences == targ_seq ]
}

summary_cloneFrac <- summary_cloneFrac %>%
  mutate(
    sum_cloneFrac = rowSums( subset(summary_cloneFrac, select = -c(targetSequences, Total)) )
  ) %>%
  rename(nonzero_counts = Total) %>%
  arrange(desc(nonzero_counts), desc(sum_cloneFrac)) %>%
  left_join( dat_cutoff %>% select(targetSequences,aaSeqCDR3) %>% distinct(targetSequences,aaSeqCDR3), by = "targetSequences" ) %>%
  select(targetSequences, aaSeqCDR3, everything())


# bar-plot each row of summary_cloneFrac
barplot_func <- function(row){
  barplot_df <- subset(summary_cloneFrac, select = -c(nonzero_counts, sum_cloneFrac))[row,] 
  barplot_title <- paste0("targetSequence = ", barplot_df$targetSequences, 
                          "\naaSeqCDR3 = ", barplot_df$aaSeqCDR3)
  
  barplot_df <- barplot_df %>%
    select(-c(targetSequences, aaSeqCDR3)) %>%
    pivot_longer(everything(), names_to = "antigen_sample", values_to = "clone_fraction") %>%
    # mutate(clone_fraction = round(clone_fraction,4)) %>%
    filter(clone_fraction > 0) 
  
  ggplot(data = barplot_df, aes(x = reorder(antigen_sample, -clone_fraction), y = clone_fraction)) +
    geom_bar(stat = "identity", fill = "steelblue", width = 0.3) +
    geom_text(aes(label = paste0(round(clone_fraction*100,4),"%")), vjust=-0.3, size=3) +
    labs(x = "antigen_sample", title = barplot_title) +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.text.x=element_text(size = 9))
}


# compare samples from certain antigen(s)
antigen_compare <- function(ANTIGEN){
  targetSeq_summary %>% 
    select(contains(ANTIGEN)) %>%
    mutate(sum = rowSums(.) ) %>%
    add_column(targetSequences = targetSeq_summary %>% pull(targetSequences)) %>%
    select(targetSequences, sum) %>% 
    arrange(desc(sum)) %>%
    filter(sum > 1)
}


# antigen-specific only 
antigen_compare_specific <- function(ANTIGEN){
  summary_cloneFrac %>%
    filter(nonzero_counts ==2) %>%
    filter_at(vars(contains(ANTIGEN)), ~ . >0) 
}
```

Of all `r  length(unique(dat_cutoff$targetSequences))` of the unique ``targetSequences`` among all 11 non-negative-control samples, only `r paste0(round( nrow(targetSeq_summary)/length(unique(dat_cutoff$targetSequences)) *100,4),"%")` of them have clones in more than one sample. This indicates diversity (instead of clonality) of the T-cells.     

Next, only AR805, PAP11, PAP13 and PAP19 have two samples, whereas the other antigens only have one sample. We want to see if there exists any antigen-specific sequences for these four antigens that have two samples.

### AR805

Unfortunately, there are no ``targetSequences`` or ``aaSeqCDR3`` that are specific only to AR805 (ie. sequences not seen in other antigens).

```{r, echo = T}
antigen_compare_specific("AR805")$targetSequences
```

### PAP11

There are `r antigen_compare_specific("PAP11") %>% nrow()` sequences that are specific only to PAP11. Let's plot the clone fractions for each of these sequences.

```{r, fig.width=5, fig.height=3.5, fig.align="center"}
barplot_ind <- which(summary_cloneFrac$targetSequences %in% antigen_compare_specific("PAP11")$targetSequences)

for(r in barplot_ind){
  print(barplot_func(r))
}
```

### PAP13

There are `r antigen_compare_specific("PAP13") %>% nrow()` sequences that are specific only to PAP13. Let's plot the clone fractions for each of these sequences.

```{r, fig.width=5, fig.height=3.5, fig.align="center"}
barplot_ind <- which(summary_cloneFrac$targetSequences %in% antigen_compare_specific("PAP13")$targetSequences)

for(r in barplot_ind){
  print(barplot_func(r))
}
```

### PAP19

There are also no ``targetSequences`` or ``aaSeqCDR3`` that are specific only to PAP19.

```{r, echo = T}
antigen_compare_specific("PAP19")$targetSequences
```

### Not-so-antigen-specific sequences?

For purpose of checking, we might want to look at other sequences that appear in multiple antigens too. For instance, if the sequence appears in all antigen, then well, it is not specific.  

I tabulated the clone fractions of each ``targetSequence`` in every antigen_sample. There are `r  summary_cloneFrac %>% nrow()` sequences that appear in more than one sample:

```{r}
summary_cloneFrac %>%
  knitr::kable(digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), font_size = 10) %>%
  scroll_box(width = "100%", height = "300px")
```

For example, there are a few sequences that appear in 9 out of 11 non-negative-control samples. Let's look at the clone fractions for one of these sequences:

```{r, fig.align="center"}
barplot_func(1)
```

Most of the samples have very low clone fraction for this particular sequence, so had we set a higher cutoff for ``cloneFraction``, this could be mitigated. We might also be interested in, for example, sequences that appear in some of the PAP antigens (PAP11, PAP13 or PAP19) but not in all other antigens, and the table enables us to easily extract the pattern:

```{r, echo = T}
summary_cloneFrac %>%
  filter(`AR805_S-2` == 0, `AR805_S-5` == 0, `AR811_S-5` == 0,
         (`PAP11_S-1` > 0 | `PAP11_S-4` > 0 | `PAP13_S-4` > 0 | `PAP13_S-5` > 0 | `PAP19_S-4` > 0 | `PAP19_S-5` > 0 ),
         `SSX2103_S-5` == 0, `SSX241_S-4` == 0)  %>%
  select(targetSequences, aaSeqCDR3, contains("PAP"), nonzero_counts) %>% 
  knitr::kable() %>% kable_styling(bootstrap_options = c("striped", "condensed"), font_size = 10) %>%
  scroll_box(width = "100%", height = "300px")
```

# Concluding Remarks

* Only `r paste0(round( nrow(targetSeq_summary)/length(unique(dat_cutoff$targetSequences)) *100,4),"%")` of all (unique) ``targetSequences`` have clones in more than one sample.  

* We identified `r antigen_compare_specific("PAP11") %>% nrow()` sequences that are specific only to the 2 samples of PAP11, and `r antigen_compare_specific("PAP13") %>% nrow()` sequences that are specific only to the 2 samples of PAP13. However, the clone fractions are generally small. 

* No cutoff or statistical models were included in this preliminary analysis, since number of samples are too few at the moment anyway.  

Moving forward, we need to consider:  

* trimming base pairs with low quality scores before feeding the fastq files into MiXCR?  

* use default parameters in MiXCR -- or need to tune some of them?  

* other processing steps needed after/in-conjunction-with MiXCR?  

* more statistically rigorous way of modeling clonality of sequences, as more samples are sequenced and more data becomes available.



