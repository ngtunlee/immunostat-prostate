---
title: | 
  | Antibody Responses to Different Treatments 
  | in nmCSPC Prostate Cancer Patients  
author: "Tun Lee Ng and Michael A. Newton"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  pdf_document:
    toc: true
    number_sections: true
header-includes:
   \usepackage{enumerate}
   \usepackage{amsmath}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
```

# Introduction

We would like to investigate whether different treatment induces different changes in antibody repertoires in individuals over time. To address this question, we used serum samples available from the 40 patients with nmCSPC who were treated with one of two therapies. 20 patients received standard androgen deprivation therapy (ADT; GnRh analogue given every 3 months), and 20 patients received a DNA vaccine encoding prostatic-acid phosphatase (PAP; pTVG-HP given every 14 days for 6 administrations). Samples were collected (3 replicates) from each of these patients at baseline, 3 months, and 6 months following initiation of treatment. 

```{r}
library(kableExtra)
library(allez)
library(pbkrtest) # Kenward-Roger approx
library(lme4) # linear mixed effects model
library(lmerTest) # Satterthwaite approx
library(fdrtool)
library(Rtsne)
library(heatmap3)
library(ggplot2)
library(gridExtra)
library(tidyverse) # make sure you have the latest tidyverse !


####################################################################################### 
#                           Some Common Variables and Functions                       #
####################################################################################### 

# specified color and shape scheme 
pal_proj2 <- c("turquoise1", "cornflowerblue","navy", "orchid1", "darkorange1", "firebrick1")
names(pal_proj2) <- c("ADT_0", "ADT_3", "ADT_6", "PAP_0", "PAP_3", "PAP_6")
shp_proj2 <- c(8, 15, 16, 3, 17, 18)
shp_proj2 <- c(8, 16, 18, 8, 16, 18)
names(shp_proj2) <- names(pal_proj2)

# function to plot PCA loadings
PCload.func <- function(cols, shapes, U, D, x, y, pca.vec, title){
  Z <- U %*% diag(D)
  plot(Z[,x], Z[,y], col = cols, pch = shapes, main = title,
       xlab = paste0("PC",x," (", round(pca.vec[x]*100, 1) ,"% variance explained)"),
       ylab = paste0("PC",y," (", round(pca.vec[y]*100, 1) ,"% variance explained)") 
  )
}


# function to count peptides at different FDR thresholds
count.func <- function(pval.vec, thresh.vec){
  counter <- NULL
  for (i in thresh.vec ){
    counter <- c(counter, length(pval.vec[pval.vec <= i]))
  }
  countab <- rbind(c("FDR threshold", thresh.vec),
                   c("Peptide counts", counter))
  return(countab)
}

# typical step in FDR adjustment for LMM pval
LMM_func_proj2 <- function(LMM_pval){
  # control FDR
  LMM_BH <- p.adjust(LMM_pval, method = "BH")
  LMM_qval <- fdrtool(LMM_pval, statistic = "pvalue", verbose = F, plot  = F)$qval
  LMM_qval_eta0 <- unname(fdrtool(LMM_pval, statistic = "pvalue", verbose = F, plot  = F)$param[,"eta0"])
  
  # plot histogram of p-values
  all_peptide_hist <- hist(LMM_pval, breaks = 70, freq = F, xlab = "Linear Mixed Models (LMM) p-values", 
                           main = paste0("p-values distribution for ", length(LMM_pval), " peptides"))
  polygon_ind <- which(all_peptide_hist$density >= LMM_qval_eta0)
  for (i in polygon_ind){
    polygon( x = c(all_peptide_hist$breaks[i], all_peptide_hist$breaks[i+1], all_peptide_hist$breaks[i+1], all_peptide_hist$breaks[i]),
             y = c(all_peptide_hist$density[i], all_peptide_hist$density[i], LMM_qval_eta0, LMM_qval_eta0),
             col = "red")
  }
  text(x=0.65,y=4, labels = paste( "estimated proportion of \nnon-null peptides =",
                                   round( 100*(1 - LMM_qval_eta0),2 ),"%" ))
  
  return(list(LMM_BH = LMM_BH, LMM_qval = LMM_qval, LMM_qval_eta0 = LMM_qval_eta0))
}


load("05_TestTreat_REML.RData")
load("05_TestTreat_NoREML.RData")
raw_data_median_proj2 <- read_csv("raw_data_median_proj2.csv")

####################################################################################### 
#                                      Data Processing                                #
####################################################################################### 

array_id_key_proj2 = read_tsv("sample_key_project2.txt") %>%
  janitor::clean_names() %>% 
  rename(treatment = condition,
         array_id = "file_name") %>%
  mutate(id = tolower(id))

sample_key_proj2 = array_id_key_proj2 %>%
  group_by(id, time) %>% 
  summarize(n = n()) %>%
  ungroup() %>%
  filter(n>=2) 

# remove patients with no replicates
array_id_key_proj2 = array_id_key_proj2 %>% 
  filter(id %in% sample_key_proj2$id)

# make sure sample_key_proj2 align with raw_data_median_proj2
sample_key_proj2 <- sample_key_proj2 %>%
  select(-n) %>%
  arrange(time, id)
sample_key_proj2 <- sample_key_proj2 %>% 
  left_join(array_id_key_proj2 %>% select(id, treatment) %>% distinct())
```

We take $\log_2$ transformation on the fluorescence levels prior to subsequent steps in our analysis. In order to verify normalization of the fluorescence level, we also plot the boxplots of median (across replicates) $\log_2$ fluorescence level of all peptides for each patient.

```{r, fig.height = 5, cache = T, dependson=c("raw_data_median_proj2", "sample_key_proj2")}
median_long_proj2 <- raw_data_median_proj2 %>%
  select(contains("id:")) %>%
  pivot_longer(cols = everything(), names_to = "id_time", values_to = "fluorescence") 

# set fill color
median_long_proj2$treat_time <- rep( paste(sample_key_proj2$treatment, sample_key_proj2$time, sep = "_"), 177604)

# sort order of patients in boxplot
median_long_proj2$id_time <- factor(median_long_proj2$id_time, levels = c(
  unique(median_long_proj2$id_time[median_long_proj2$treat_time == "ADT_0"]),
  unique(median_long_proj2$id_time[median_long_proj2$treat_time == "ADT_3"]),
  unique(median_long_proj2$id_time[median_long_proj2$treat_time == "ADT_6"]),
  unique(median_long_proj2$id_time[median_long_proj2$treat_time == "Vaccine_0"]),
  unique(median_long_proj2$id_time[median_long_proj2$treat_time == "Vaccine_3"]),
  unique(median_long_proj2$id_time[median_long_proj2$treat_time == "Vaccine_6"])
))

ggplot(median_long_proj2, aes(x = id_time, y = fluorescence, fill = treat_time)) +
  geom_boxplot(outlier.shape = ".") +
  # scale_fill_discrete(name="Stage") +
  # guides(fill=guide_legend(title="Stage")) +
  scale_fill_manual(name = "treatment_time", values = c("turquoise1", "cornflowerblue","navy", 
                                                        "orchid1", "darkorange1", "firebrick1")) +
  labs(title = "Boxplots of Peptide Fluorescence Levels for Patients at 3 time points", 
       x = "Patient_Time", y = "Median Fluorescence Levels on log2 scale") +
  theme(panel.background = element_rect(fill = "grey90"),
        panel.grid.major = element_line(color = "white"),
        panel.grid.minor = element_line(color = "white"),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 3),
        legend.position = "bottom",
        plot.title = element_text(hjust = 0.5))
```

It appears that the fluorescence levels of the peptides are normalized. 

# Statistical Test for Treatment Effects

For each of the peptides, we test the following:   

$H_0$: Different treatments (regardless of whether ADT or PAP) do not result in different antibody responses over time.  
$H_1$: Different treatments lead to different antibody responses over time.  

We deploy the following nested linear mixed-models using R package *lme4*:  

**Null model**:  

pseudo-syntax: lmer(fluorescence ~ time + (1 + time | patient))  

In mathematical notation, let $y_{j \tau}$ be the median fluorescence level on $\log_2$ scale for the $j^{th}$ patient at time $\tau$,  

$$
y_{j\tau} = \beta_0 + \beta_1 \tau + b_{0j} + b_{1j} \tau + \epsilon_{j},  
$$
where  

* $\beta_0$ = the baseline antibody response level for all patients
* $\tau$ = 0, 3 or 6 months
* $j = 1, \cdots, 20$ indexes the patients at time $\tau$
* $b_{0j}$ is the random intercept of the $j^{th}$ patient
* $b_{1j}$ is the random slope of the $j^{th}$ patient
* $\left( \begin{smallmatrix} b_{0j} \\ b_{1j} \\ \epsilon_j \end{smallmatrix} \right)$ $\sim N_3$ $\left( \left[ \begin{smallmatrix} 0 \\ 0 \\ 0 \end{smallmatrix} \right] , \Sigma = \left[ \begin{smallmatrix} \sigma_0^2 & \rho \sigma_0 \sigma_1 & 0 \\ \rho \sigma_0 \sigma_1 & \sigma_1^2 & 0 \\ 0 & 0 & \sigma^2_{\epsilon} \end{smallmatrix} \right] \right)$

**Alternative model**:

pseudo-syntax: lmer(fluorescence ~ treatment + time + treatment:time + (1 + time | patient))  

In mathematical notation,  

$$
y_{ij\tau} = \beta_0 + \beta_1 \tau + \beta_2 x_i + \beta_3 x_i \tau + b_{0j} + b_{1j} \tau + \epsilon_{ij},  
$$
where  

* $\beta_0$ = the baseline antibody response level for patients administered with ADT.
* $\tau$ = 0, 3 or 6 months
* $x_i = 1$ if patient is administered with PAP vaccine and 0 otherwise
* $\beta_2 + \beta_3 \tau$ represents the difference in antibody response level due to the PAP vaccine compared to ADT at time $\tau$
* $j = 1, \cdots, 10$ indexes the patients at time $\tau$ for each of the 2 treatment types
* $b_{0j}$ is the random intercept of the $j^{th}$ patient
* $b_{1j}$ is the random slope of the $j^{th}$ patient
* $\left( \begin{smallmatrix} b_{0j} \\ b_{1j} \\ \epsilon_{ij} \end{smallmatrix} \right)$ $\sim N_3$ $\left( \left[ \begin{smallmatrix} 0 \\ 0 \\ 0 \end{smallmatrix} \right] , \Sigma = \left[ \begin{smallmatrix} \sigma_0^2 & \rho \sigma_0 \sigma_1 & 0 \\ \rho \sigma_0 \sigma_1 & \sigma_1^2 & 0 \\ 0 & 0 & \sigma^2_{\epsilon} \end{smallmatrix} \right] \right)$

In other words, we are testing  

$H_0$: $\beta_2 = \beta_3 = 0$.  
$H_1$: Not both $\beta_2$ and $\beta_3$ are zeroes.  

**Rationale of the models**:  Since each patient has multiple measurements, the random effects of the mixed model allow us to capture the within-subject interdepencies. Every patient's antibody response is unique and possibly changes across time due to individual circumstances, so we want our model to include random intercept (representing patient-specific randomness) and random slope (of time). Since measurements were taken across only 3 time points, we refrain from considering more complicated random effects. Where fixed effects are concerned, both types of treatments could lead to a change in antibody response *over time across all patients*, which would be captured in the *time fixed effect*. The alternative model has the additional terms of treatment main effect and treatment-time interaction effects. If different treatments (regardless of whether ADT or PAP) do not result in different antibody responses over time, then these two additional terms could be dropped.  

**Model-fitting and Test Statistics**: Hypothesis testing in linear mixed-models is still an active area of research. Due to the large number of peptides, any non-parametric tests like permutation tests (shuffling treatment identifiers among patients by respecting time blocks) are prohibitively expensive in terms of computation. There are three usual parametric approximate tests for fixed effects in linear mixed models:  

* Kenward-Roger (KR) approximate F-test, with model estimates fitted using the Restricted Maximum Likelihood (REML) approach,
* Satterthwaite approximate F-test, with model estimates also fitted with REML, and
* likelihood ratio test (LRT), with model estimates fitted using the usual Maximum Likelihood (ML) approach.  

Roughly, unlike the ML approach, the REML method gives unbiased estimate of $\widehat{\Sigma}$. This is imperative, since $\widehat{\Sigma}$ feeds into the F-test calculations. Both Kenward_Roger and Satterthwaite approximations aim to adjust the degrees-of-freedom in the F-test to account for the additional estimation of covariance terms in the random effects of mixed models, as compared to a vanilla F-test in basic linear models. Likelihood ratio test is only meaningful when parameter estimates are fitted with ML, otherwise the likelihood ratio test statistic may even end up as a negative value.  

None of the three tests are uniformly "better" (depends on your own metric) than the others. The consensus is that likelihood ratio test (LRT) could be slightly more liberal than the other two methods. KR and Satterthwaite approximations usually give comparable results, and the Satterthwaite method is also the default linear-mixed-model setting in SAS and in the R package *lmerTest*. (Need to fill in citations for this paragraph)  

**Statistical Results**

We applied all three methods to obtain the p-values for each of the 177,604 peptides. 

```{r, fig.width=9}
LR_NoREML_pval <- pchisq( -2 * ( LMM_proj2_NoREML$loglik_fit0 - LMM_proj2_NoREML$loglik_fit1 ), df = 2, lower.tail = F ) 

plot_pval_thresh <- 1

par(mfrow=c(1,2))

# compare Satterthwaite approx p-val vs KR approx F-test pval
plot(x = KR_lmer_proj2$satterthwaite_pval[KR_lmer_proj2$satterthwaite_pval <= plot_pval_thresh & 
                                            KR_lmer_proj2$pval_proj2 <= plot_pval_thresh], 
     y = KR_lmer_proj2$pval_proj2[KR_lmer_proj2$satterthwaite_pval <= plot_pval_thresh & 
                                    KR_lmer_proj2$pval_proj2 <= plot_pval_thresh], 
     pch = ".", xlab = "Satterthwaite pval (REML=TRUE)", ylab = "KR F-test pval (REML=TRUE)",
     main = "KR vs Satterthwaite")
abline(a= 0, b = 1, col = "blue", lty = 2)

# compare LRT chisq p-val vs KR approx F-test pval
plot_pval_thresh <- 1
plot(x = LR_NoREML_pval[LR_NoREML_pval <= plot_pval_thresh & KR_lmer_proj2$pval_proj2 <= plot_pval_thresh], 
     y = KR_lmer_proj2$pval_proj2[LR_NoREML_pval <= plot_pval_thresh & KR_lmer_proj2$pval_proj2 <= plot_pval_thresh], 
     pch = ".", xlab = "LRT chisq pval (REML=FALSE)", ylab = "KR F-test pval (REML=TRUE)",
     main = "KR vs LRT")
abline(a= 0, b = 1, col = "blue", lty = 2)
```

It appears that in our case, the Kenward-Roger approximate F-tests give the most conservative p-values out of the 3 methods. Our subsequent analysis will be based on the Kenward-Roger(KR) p-values.  

First, we obtain the p-values histogram.

```{r}
# get p-values histogram and FDR 
KR_LMM <- LMM_func_proj2(KR_lmer_proj2$pval_proj2)
```

The red-shaded regions of the histogram represents the estimated proportion of non-null peptides in the dataset based on Storey's q-values calculation obtained via the R package ``fdrtool``. The q-value is similar to the well known p-value, except that it is a measure of significance in terms of the false discovery rate rather than the false positive rate. 

We apply the Benjamini-Hochberg (BH) method on the KR p-values to control for false discovery rate (FDR). The peptide counts at various BH FDR thresholds are tabulated below. 

```{r}
kable( count.func(KR_LMM$LMM_BH, seq(0.01, 0.1, by = 0.01)),
       format = "latex", row.names= NA, col.names = NA, booktabs = T )%>%
  kable_styling(latex_options = c("scale_down", "hold_position")) %>%
  row_spec(1, hline_after = T)
```

# Visualization of Treatment Effects

```{r, include = F}
Satterthwaite_LMM <- LMM_func_proj2(KR_lmer_proj2$satterthwaite_pval)
```

```{r}
BH_FDR_cutoff <- 0.01
# Eff_time0 <- 1
Eff_time3 <- 1
Eff_time6 <- 1
signif_crit <- (KR_LMM$LMM_BH <= BH_FDR_cutoff) & 
  (Satterthwaite_LMM$LMM_BH <= BH_FDR_cutoff) &
  # ( LMM_proj2_NoREML$Treat_Main  >= Eff_time0 ) &
  ( (LMM_proj2_NoREML$Treat_Main + 3 * LMM_proj2_NoREML$Treat_Time) >= Eff_time3 ) &
  ( (LMM_proj2_NoREML$Treat_Main + 6 * LMM_proj2_NoREML$Treat_Time) >= Eff_time6 )
signif_crit_sum <- sum(as.numeric(signif_crit))

anova_dat_demean <- as.matrix( KR_lmer_proj2 %>% select(contains("id:")) )[ signif_crit , ]
treat_time <- paste(
  toupper( substr(colnames(anova_dat_demean), 4,6) ),
  str_sub( colnames(anova_dat_demean), -1,-1 ), sep = "_"
) 
anova_dat_demean3 <- anova_dat_demean[ , (treat_time == "ADT_3") | (treat_time == "PAP_3") ]
anova_dat_demean3 <- sweep(anova_dat_demean3, 1,  rowMeans(anova_dat_demean3), "-") # centering by row

# colors and shapes for the visualization techniques
cols_time3 = pal_proj2[ match(treat_time[(treat_time == "ADT_3") | (treat_time == "PAP_3")], names(pal_proj2)) ]
shapes_time3 = shp_proj2[  match(treat_time[(treat_time == "ADT_3") | (treat_time == "PAP_3")], names(shp_proj2)) ]
pal_time3 <- c("blue", "red")
names(pal_time3) <- c("ADT_3", "PAP_3")
cols_time3 = pal_time3[ match(treat_time[(treat_time == "ADT_3") | (treat_time == "PAP_3")], names(pal_time3)) ]
```

It appears that treatment effects are prominent among many peptides. For the purpose of visualizing more prominent treatment effects brought about by PAP vaccine as compared to ADT, we will focus on the significant peptides at 1 \% FDR and that the PAP vaccine leads to an estimated increase of two-fold in antibody response as compared to ADT at times 3-months and 6-months, ie. $\left( \widehat{\beta}_2 + 3 \times \widehat{\beta}_3 \right) \geq 1$ and $\left( \widehat{\beta}_2 + 6 \times \widehat{\beta}_3 \right) \geq 1$. There are `r signif_crit_sum` peptides that fulfill these criteria.

We obtain the residuals of the null model at times 3-months and 6-months, and plot these residuals using the PCA, t-SNE and heatmap approaches. Any observed clustering patterns based on treatment types would reveal the treatment effects not captured in the null model. We find that the clustering patterns are more obvious at 6-months' time than at 3-months' time. 

## Treatment Effects at 3 months

```{r}
# PCA -- focus on heatmap at time 3?

# svd
sv.dat <- sweep(t(anova_dat_demean3), 2, colMeans(t(anova_dat_demean3)), "-") # centering
sv <- svd(sv.dat)
V <- sv$v
D <- sv$d
U <- sv$u

# variance explained
pca.var <- D^2/sum(D^2) 
pca.cumvar <- cumsum(pca.var)

# plot PCA
par(mfrow = c(1,2), pty = "s", mar = c(2.2,2.3,1.5,0.45), mgp = c(1.4,0.4,0),
    cex.axis = 0.84, cex.lab = 0.84, cex.main = 0.84, tcl = -0.4)
PCload.func(cols_time3, shapes_time3, U, D, 1, 2, pca.var, title = "PC2 vs PC1") # PC loadings (PC2 vs PC1)
legend('topright', cex = 0.5, pch = shp_proj2[c('ADT_3','PAP_3')], col = pal_proj2[c('ADT_3','PAP_3')], c('ADT_3','PAP_3') )
PCload.func(cols_time3, shapes_time3, U, D, 3, 2, pca.var, title = "PC2 vs PC3") # PC loadings (PC2 vs PC3)
```

```{r, fig.height=6, cache = T, dependson=c("anova_dat_demean3")}
# t-SNE -- focus on heatmap at time 3?

# how to specify parameter
# refer: https://lvdmaaten.github.io/tsne/User_guide.pdf

tsnedat <- unname(t(anova_dat_demean3)) # dim(X) = N samples by D dimensions 
initdim <- 40 
perplex <- 13 

set.seed(10)
tsne_anova <- Rtsne(tsnedat, initial_dims = initdim, perplexity = perplex,
                    theta = 0, check_duplicates = F, max_iter = 50000L, eta = 50)

# t-SNE plot
plot(tsne_anova$Y, ylab = "", xlab = "", col = cols_time3, pch = shapes_time3, main = "t-SNE plot")
# legend('topleft', pch = shp_proj2[c('ADT_3','PAP_3')], col = pal_proj2[c('ADT_3','PAP_3')], c('ADT_3','PAP_3'))
legend('topright', pch = shp_proj2[c('ADT_3','PAP_3')], col = pal_time3, c('ADT_3','PAP_3'))
```

```{r, fig.height = 10, fig.width = 8, cache = T, dependson=c("anova_dat_demean3")}
# heatmap color palette
cls <- colorRampPalette(c("navy", "royalblue1", "white", "firebrick1", "brown4"))(n = 1024)

heatmap3(anova_dat_demean3, 
         col = cls, # specify colors 
         ColSideColors = cols_time3, # specify patient color code
         labCol = colnames(anova_dat_demean3), # specify patient
         ColSideLabs = "treatment", 
         labRow = "",
         xlab = "",
         # legendfun=function() showLegend(col = pal_proj2[c('ADT_3','PAP_3')],
         #                                 legend = c('ADT_3','PAP_3'),
         #                                 cex = 1.2,
         #                                 lwd = 5  )
)
```

## Treatment Effects at 6 months

```{r}
anova_dat_demean6 <- anova_dat_demean[ , (treat_time == "ADT_6") | (treat_time == "PAP_6") ]
anova_dat_demean6 <- sweep(anova_dat_demean6, 1,  rowMeans(anova_dat_demean6), "-") # centering by row

# colors and shapes for the visualization techniques
cols_time6 = pal_proj2[ match(treat_time[(treat_time == "ADT_6") | (treat_time == "PAP_6")], names(pal_proj2)) ]
shapes_time6 = shp_proj2[  match(treat_time[(treat_time == "ADT_6") | (treat_time == "PAP_6")], names(shp_proj2)) ]
pal_time6 <- c("blue", "red")
names(pal_time6) <- c("ADT_6", "PAP_6")
cols_time6 = pal_time6[ match(treat_time[(treat_time == "ADT_6") | (treat_time == "PAP_6")], names(pal_time6)) ]
```

```{r}
# PCA -- focus on heatmap at time 6?

# svd
sv.dat <- sweep(t(anova_dat_demean6), 2, colMeans(t(anova_dat_demean6)), "-") # centering
sv <- svd(sv.dat)
V <- sv$v
D <- sv$d
U <- sv$u

# variance explained
pca.var <- D^2/sum(D^2) 
pca.cumvar <- cumsum(pca.var)

# plot PCA
par(mfrow = c(1,2), pty = "s", mar = c(2.2,2.3,1.5,0.45), mgp = c(1.4,0.4,0),
    cex.axis = 0.84, cex.lab = 0.84, cex.main = 0.84, tcl = -0.4)
PCload.func(cols_time6, shapes_time6, U, D, 1, 2, pca.var, title = "PC2 vs PC1") # PC loadings (PC2 vs PC1)
legend('topright', cex = 0.5, pch = shp_proj2[c('ADT_6','PAP_6')], col = pal_proj2[c('ADT_6','PAP_6')], c('ADT_6','PAP_6') )
PCload.func(cols_time6, shapes_time6, U, D, 3, 2, pca.var, title = "PC2 vs PC3") # PC loadings (PC2 vs PC3)
```

```{r, fig.height=6, cache = T, dependson=c("anova_dat_demean6")}
# t-SNE -- focus on heatmap at time 6?

# how to specify parameter
# refer: https://lvdmaaten.github.io/tsne/User_guide.pdf

tsnedat <- unname(t(anova_dat_demean6)) # dim(X) = N samples by D dimensions 
initdim <- 40 
perplex <- 13 

set.seed(10)
tsne_anova <- Rtsne(tsnedat, initial_dims = initdim, perplexity = perplex,
                    theta = 0, check_duplicates = F, max_iter = 50000L, eta = 50)

# t-SNE plot
plot(tsne_anova$Y, ylab = "", xlab = "", col = cols_time6, pch = shapes_time6, main = "t-SNE plot")
# legend('topleft', pch = shp_proj2[c('ADT_6','PAP_6')], col = pal_proj2[c('ADT_6','PAP_6')], c('ADT_6','PAP_6'))
legend('topleft', pch = shp_proj2[c('ADT_6','PAP_6')], col = pal_time6, c('ADT_6','PAP_6'))
```


```{r, fig.height = 10, fig.width = 8, cache = T, dependson=c("anova_dat_demean6")}
cls <- colorRampPalette(c("navy", "royalblue1", "white", "firebrick1", "brown4"))(n = 1024)

heatmap3(anova_dat_demean6, 
         col = cls, # specify colors 
         ColSideColors = cols_time6, # specify patient color code
         labCol = colnames(anova_dat_demean6), # specify patient
         ColSideLabs = "treatment", 
         labRow = "",
         xlab = "",
         # legendfun=function() showLegend(col = pal_proj2[c('ADT_6','PAP_6')],
         #                                 legend = c('ADT_6','PAP_6'),
         #                                 cex = 1.2,
         #                                 lwd = 5  )
)
```

## Boxplots of a few Significant Peptides

We also show the boxplots of fluorescence levels for a few significant peptides.

```{r, fig.height = 11, fig.width=8.5}
BH_FDR_cutoff <- 0.0001
# Eff_time0 <- 1
Eff_time3 <- 2
Eff_time6 <- 2
signif_crit <- (KR_LMM$LMM_BH <= BH_FDR_cutoff) & 
  (Satterthwaite_LMM$LMM_BH <= BH_FDR_cutoff) &
  # ( LMM_proj2_NoREML$Treat_Main  >= Eff_time0 ) &
  ( (LMM_proj2_NoREML$Treat_Main + 3 * LMM_proj2_NoREML$Treat_Time) >= Eff_time3 ) &
  ( (LMM_proj2_NoREML$Treat_Main + 6 * LMM_proj2_NoREML$Treat_Time) >= Eff_time6 )

signif_median <- raw_data_median_proj2 %>% 
  select(PROBE_ID, contains("id:")) %>%
  filter( signif_crit )

signif_total_eff <- 2*(LMM_proj2_NoREML$Treat_Main)[signif_crit] + 9*(LMM_proj2_NoREML$Treat_Time)[signif_crit]
signif_median <- signif_median[ order(signif_total_eff, decreasing = T),]

signif_boxplot.func <- function(signif_mat, draw){
  signif_mat2 <- signif_mat[,-1]
  signif_df <- data.frame(
    treatment = factor( toupper( substr(colnames(signif_mat2), 4,6) ) ),
    time = factor( str_sub( colnames(signif_mat2), -1,-1 ) ), 
    fluorescence = as.numeric(signif_mat2[draw,])
  )
  ggplot(signif_df, aes(x = time, y = fluorescence, fill = treatment)) +
    geom_boxplot(width = 0.5, position=position_dodge2(width = 0.5)) +
    labs(title = paste0("Boxplots of Fluorescence Levels for \nSignif Peptide: ", 
                        signif_mat$PROBE_ID[draw]), 
         x = "Time", y = "log2 Median Fluorescence") +
    scale_fill_manual(values=c("#00BFC4", "#F8766D")) +
    ylim(c(2,15.5)) +
    theme(panel.background = element_rect(fill = "grey90"),
          panel.grid.major = element_line(color = "white"),
          panel.grid.minor = element_line(color = "white"),
          # legend.position = "bottom",
          plot.title = element_text(hjust = 0.5))
}

grid.arrange(
  signif_boxplot.func(signif_median,1),
  signif_boxplot.func(signif_median,2),
  signif_boxplot.func(signif_median,3),
  signif_boxplot.func(signif_median,4),
  signif_boxplot.func(signif_median,5),
  signif_boxplot.func(signif_median,6),
  ncol = 2
)
```

# Gene-Set Analysis (Genes Significant for Treatment Effects)

```{r}
fdr5_count <- count.func(KR_LMM$LMM_BH, seq(0.01, 0.1, by = 0.01))[2,6]
fdr1_count <- count.func(KR_LMM$LMM_BH, seq(0.01, 0.1, by = 0.01))[2,2]
```


```{r}
BH_FDR_cutoff <- 0.01
# Eff_time0 <- 1
Eff_time3 <- 1
Eff_time6 <- 1
signif_crit <- (KR_LMM$LMM_BH <= BH_FDR_cutoff) & 
  (Satterthwaite_LMM$LMM_BH <= BH_FDR_cutoff) &
  # ( LMM_proj2_NoREML$Treat_Main  >= Eff_time0 ) &
  ( (LMM_proj2_NoREML$Treat_Main + 3 * LMM_proj2_NoREML$Treat_Time) >= Eff_time3 ) &
  ( (LMM_proj2_NoREML$Treat_Main + 6 * LMM_proj2_NoREML$Treat_Time) >= Eff_time6 )

# read uniprot_gene csv
uniprot_gene <- read_csv("uniprot_data_entrez.csv", col_types = cols_only(
  seq_id = col_character(),
  uniprot_id = col_character(),
  gene_symbol = col_character(),
  entrez_gene_id_pete = col_double(),
  gene_names = col_character(),
  protein_names = col_character()
)) %>% filter(!(is.na(seq_id)) & !(is.na(entrez_gene_id_pete))) %>%
  select(seq_id, uniprot_id, gene_symbol, entrez_gene_id_pete, gene_names, protein_names)

## manually changing entrez_gene_id for PCA10 & PRO29
uniprot_gene$entrez_gene_id_pete[uniprot_gene$seq_id == "PCA10"] <- 28912
uniprot_gene$entrez_gene_id_pete[uniprot_gene$seq_id == "PRO29"] <- NA
uniprot_gene <- uniprot_gene[!(is.na(uniprot_gene$entrez_gene_id_pete)),]

# get unique seq_id that are associated with significant peptides
signif_seq_id <- unique( raw_data_median_proj2$SEQ_ID[signif_crit] )
signif_seq_id <- signif_seq_id[!(is.na(signif_seq_id))] # just in case

# convert these into binary vector
seq_id_ok <- as.numeric(uniprot_gene$seq_id %in% signif_seq_id)
names(seq_id_ok) <- uniprot_gene$entrez_gene_id_pete
```

Recall that the 177604 peptides correspond to 1611 proteins, and `r nrow(uniprot_gene)` of these proteins have matching genes in *uniprot_gene_entrez.csv*. The `r fdr1_count` significant peptides at 1\% BH-FDR are associated with `r sum(seq_id_ok)` proteins with matching genes. In this analysis, we deem a protein to be significant if it has at least one significant associated peptide. We shall utilize this information to perform gene-set enrichment analysis.  

Specifically, we investigate if there are any pre-specified gene-sets that are enriched for the genes associated with the list of significant peptides. These pre-determined gene-sets are defined based on their functional categories or biological properties, such as the Gene Ontology (GO) annotations. Enriched gene-sets could reflect the biological signals in the peptide microarray data.  

The gene-set-analysis is performed with the R package ``allez``. We shall consider gene-sets containing at least 2 genes with Bonferroni-corrected enrichment p-values not exceeding 5\% . 

```{r, cache = T, dependson=c("seq_id_ok")}
# gene-set analysis via allez!
allez.go <- allez(seq_id_ok, lib = "org.Hs.eg", idtype = "ENTREZID", sets = "GO")

# nominal alpha for enrichment score
nom.alpha <- 0.05 

# minimum number of genes in gene-set to be considered 
min.num.gene <- 2
```

We display the waterfall plot of the gene-set-analysis results. 

```{r, fig.width=8.5}
# Display an image of gene scores by functional sets
allezPlot(allez.go, n.cell = min.num.gene, nominal.alpha = nom.alpha)
```

The waterfall plot was constructed by finding the significant (Bonferroni-corrected p-value < 0.05) GO term having the largest overlap with genes associated with significant peptides (nucleic acid binding GO:0003676) and placing it in the top row of the figure. We next removed these genes from the list and found the significant GO term having the highest overlap with the remainder of the list (ion binding GO: 0043167). This process is repeated, and genes identified by this sequential process are counted along the x-axis, and the overlap between the GO terms can be visually assessed. Shading under the 'waterfall' component of the graph indicates genes that were annotated to previously named categories.

We also tabulate the enriched/overrepresented GO terms. 

```{r}
# tabulate enriched gene-set with signif genes only
allez.tab <- allezTable(allez.go, symbol = T, n.cell = min.num.gene, nominal.alpha = nom.alpha, in.set = T)
allez.tab$set.size <- paste(allez.tab$in.set, allez.tab$set.size, sep = "/")
allez.tab <- allez.tab %>% dplyr::select(-c(in.set, genes)) %>%
  mutate(in.genes = str_replace_all(in.genes, ";", "; "))

kable(allez.tab, format = "latex", digits = 4, booktabs = T, longtable = T) %>%
      kable_styling(latex_options = c("hold_position", "repeat_header"),
                    full_width = T, font_size = 6) %>%
      column_spec(1, width = "12em") %>%
      column_spec(6, width = "30em")
```

# Concluding Remarks

* Counts of significant peptides: `r fdr5_count` at 5\% FDR and `r fdr1_count` at 1\% FDR.  

* Out of the `r fdr1_count` peptides at 1\% FDR, `r signif_crit_sum` of them also exhibit an increase in fluorescence by two-fold due to the PAP vaccine effect as compared to ADT at both times 3-months and 6-months.  

* These `r signif_crit_sum` peptides demonstrate more obvious clustering effect (based on treatment types) in the PCA, t-SNE and heatmap at 6 month's time rather than at 3 month's time. This also suggests presence of *time* fixed effect in the data set.  

* The gene-sets found to be enriched by the genes associated with the significant peptides are comparable to the gene-sets identified in (Figure 5 of) the main manuscript. 